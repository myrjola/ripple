<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="A meditation timer that works with the screen locked">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Meditation Timer">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon"
          href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><circle cx='90' cy='90' r='85' fill='%23667eea'/></svg>">
    <title>Meditation Timer</title>
</head>
<body>
<h1>Meditation Timer</h1>
<div id="timer">10</div>
<div id="countdown"></div>
<p id="status">Ready</p>
<div id="presetButtons">
    <button data-duration="300" class="preset-btn">5 min</button>
    <button data-duration="600" class="preset-btn">10 min</button>
    <button data-duration="900" class="preset-btn">15 min</button>
    <button data-duration="1200" class="preset-btn">20 min</button>
</div>
<div id="controlButtons">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
</div>

<script>
    class MeditationTimer {
        // ==================== Configuration ====================

        static DURATION = 10;                  // Default duration in seconds
        static COUNTDOWN_DELAY = 5;            // Seconds to count down before meditation starts
        static BELL_SEQUENCE_DURATION = 27;    // Duration of ending bell sequence (21s for 4 bells + ~6s decay)
        static COMPLETION_BELL_INTERVALS = [0, 7000, 14000, 21000];  // Bell timing at end of session
        static AUTO_STOP_DELAY = 28000;        // Auto-stop after final bell sequence

        // ==================== Private State ====================

        // Audio
        #audioContext = null;
        #oscillator = null;
        #gain = null;
        #activeNodes = [];
        #bellTimeouts = [];

        // Timers
        #intervalId = null;
        #countdownId = null;
        #completionTimeoutId = null;

        // Timing state (wall-clock based for accuracy when app is backgrounded)
        #delayStartTime = null;
        #meditationStartTime = null;
        #timeRemaining = MeditationTimer.DURATION;
        #selectedDuration = 10;

        // Platform APIs
        #wakeLock = null;

        // DOM elements
        #elements;

        // ==================== Initialization ====================

        constructor() {
            // Cache DOM elements
            this.#elements = {
                timer: document.getElementById('timer'),
                startBtn: document.getElementById('startBtn'),
                stopBtn: document.getElementById('stopBtn'),
                status: document.getElementById('status'),
                countdown: document.getElementById('countdown'),
            };

            // Bind control buttons
            this.#elements.startBtn.addEventListener('click', () => this.start());
            this.#elements.stopBtn.addEventListener('click', () => this.stop());

            // Bind duration preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => this.#selectDuration(e.target));
            });

            // Handle page visibility changes (e.g., returning from lock screen)
            // Re-acquires wake lock and syncs display with wall-clock time
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    if (this.#wakeLock !== null) {
                        await this.#requestWakeLock();
                    }
                    if (this.#delayStartTime !== null) {
                        this.#tickCountdown();
                    } else if (this.#meditationStartTime !== null) {
                        this.#tick();
                    }
                }
            });

            this.#updateTimerDisplay();
        }

        // ==================== Public API ====================

        async start() {
            this.#resetAudio();
            this.#setupAudioSession();
            this.#updateMediaSession();
            this.#startSilentAudio();
            await this.#requestWakeLock();

            this.#timeRemaining = this.#selectedDuration;
            this.#updateTimerDisplay();
            this.#elements.status.textContent = 'Get ready';
            this.#setButtonState(true);
            this.#updateMediaSessionPosition();

            // Begin countdown phase
            this.#elements.timer.style.display = 'none';
            this.#delayStartTime = Date.now();
            this.#elements.countdown.textContent = String(MeditationTimer.COUNTDOWN_DELAY);
            this.#countdownId = setInterval(() => this.#tickCountdown(), 100);
        }

        async stop() {
            // Clear all timers
            clearInterval(this.#intervalId);
            clearInterval(this.#countdownId);
            clearTimeout(this.#completionTimeoutId);
            this.#completionTimeoutId = null;
            this.#meditationStartTime = null;

            // Stop audio
            this.#stopAllBells();
            this.#stopSilentAudio();

            // Release platform resources
            this.#setMediaSessionPlaying(false);
            await this.#releaseWakeLock();

            // Reset UI
            this.#delayStartTime = null;
            this.#elements.timer.style.display = 'block';
            this.#elements.countdown.textContent = '';
            this.#timeRemaining = this.#selectedDuration;
            this.#updateTimerDisplay();
            this.#elements.status.textContent = 'Stopped';
            this.#setButtonState(false);
            this.#updateMediaSessionPosition();
        }

        // ==================== Duration Selection ====================

        #selectDuration(button) {
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            this.#selectedDuration = parseInt(button.dataset.duration);
            this.#timeRemaining = this.#selectedDuration;
            this.#updateTimerDisplay();
        }

        #updateTimerDisplay() {
            const minutes = Math.floor(this.#timeRemaining / 60);
            const seconds = this.#timeRemaining % 60;
            this.#elements.timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // ==================== Timer Logic ====================

        // Handles the pre-meditation countdown (5, 4, 3, 2, 1...)
        // Uses wall-clock time to stay accurate even if the app is backgrounded
        #tickCountdown() {
            const elapsed = Date.now() - this.#delayStartTime;
            const remaining = Math.ceil((MeditationTimer.COUNTDOWN_DELAY * 1000 - elapsed) / 1000);

            if (remaining > 0) {
                this.#elements.countdown.textContent = remaining;
            } else {
                // Countdown complete - transition to meditation phase
                clearInterval(this.#countdownId);
                this.#countdownId = null;
                this.#elements.timer.style.display = 'block';
                this.#elements.countdown.textContent = '';
                this.#delayStartTime = null;

                // Start meditation
                this.#meditationStartTime = Date.now();
                this.#playBell();
                this.#elements.status.textContent = 'Timer running...';

                // Schedule completion using wall-clock timeout for reliability
                // (setInterval can drift or pause when backgrounded)
                this.#completionTimeoutId = setTimeout(() => {
                    if (this.#meditationStartTime !== null) {
                        this.#timeRemaining = 0;
                        this.#updateTimerDisplay();
                        this.#complete();
                    }
                }, this.#selectedDuration * 1000);

                // Update display every second (visual only - completion is timeout-based)
                this.#intervalId = setInterval(() => this.#tick(), 1000);
            }
            this.#updateMediaSessionPosition();
        }

        // Updates the display during meditation
        // Calculates remaining time from wall-clock for accuracy after backgrounding
        #tick() {
            const elapsed = Math.floor((Date.now() - this.#meditationStartTime) / 1000);
            this.#timeRemaining = Math.max(0, this.#selectedDuration - elapsed);
            this.#updateTimerDisplay();
            this.#updateMediaSessionPosition();

            if (this.#timeRemaining <= 0) {
                this.#complete();
            }
        }

        // Called when meditation time is up
        // Plays a sequence of bells spaced 7 seconds apart to gently bring user back
        async #complete() {
            clearInterval(this.#intervalId);
            clearTimeout(this.#completionTimeoutId);
            this.#completionTimeoutId = null;
            this.#meditationStartTime = null;
            this.#stopSilentAudio();
            this.#setMediaSessionPlaying(false);

            this.#elements.timer.textContent = '0:00';
            this.#elements.status.textContent = 'Time up!';
            this.#setButtonState(false);
            this.#updateMediaSessionPosition();

            // Play completion bell sequence
            MeditationTimer.COMPLETION_BELL_INTERVALS.forEach(delay => {
                if (delay === 0) {
                    this.#playBell();
                } else {
                    this.#bellTimeouts.push(setTimeout(() => this.#playBell(), delay));
                }
            });

            // Auto-stop after bell sequence completes
            this.#bellTimeouts.push(setTimeout(() => this.stop(), MeditationTimer.AUTO_STOP_DELAY));
        }

        // ==================== Audio: Context & Silent Background ====================

        // Initializes or resumes the Web Audio context
        // Must handle 'suspended' state because browsers require user interaction before audio
        #initAudioContext() {
            if (!this.#audioContext) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.#audioContext = new AudioContext({latencyHint: 'playback'});
            }
            if (this.#audioContext.state === 'suspended') {
                this.#audioContext.resume();
            }
        }

        // Plays an inaudible tone to keep the audio session alive
        // This allows the bell to play even when the screen is locked
        #startSilentAudio() {
            this.#initAudioContext();

            this.#oscillator = this.#audioContext.createOscillator();
            this.#gain = this.#audioContext.createGain();

            this.#oscillator.connect(this.#gain);
            this.#gain.connect(this.#audioContext.destination);

            // Near-silent: very low gain and sub-audible frequency
            this.#gain.gain.setValueAtTime(0.001, this.#audioContext.currentTime);
            this.#oscillator.frequency.value = 5;
            this.#oscillator.start();
        }

        #stopSilentAudio() {
            if (this.#oscillator) {
                this.#oscillator.stop();
                this.#oscillator = null;
                this.#gain = null;
            }
        }

        // Cleans up all audio state for a fresh start
        #resetAudio() {
            clearInterval(this.#intervalId);
            this.#stopAllBells();
            this.#stopSilentAudio();
            this.#setMediaSessionPlaying(false);
            this.#delayStartTime = null;

            if (this.#audioContext) {
                this.#audioContext.close();
                this.#audioContext = null;
            }
            this.#initAudioContext();
        }

        // ==================== Audio: Bell Sound ====================

        // Synthesizes a Tibetan singing bowl sound using additive synthesis
        #playBell() {
            this.#initAudioContext();

            const now = this.#audioContext.currentTime;
            const ctx = this.#audioContext;

            // Tibetan singing bowl partials - inharmonic frequencies with relative amplitudes and decay times
            const fundamental = 220;
            const partials = [
                {ratio: 1.0, amp: 0.4, decay: 6.0},    // fundamental
                {ratio: 2.71, amp: 0.25, decay: 4.5},  // characteristic singing bowl partial
                {ratio: 5.15, amp: 0.15, decay: 3.5},  // higher partial
                {ratio: 8.43, amp: 0.08, decay: 2.5},  // shimmer
                {ratio: 12.7, amp: 0.04, decay: 1.8},  // brightness
            ];

            // Create each partial with its own oscillator and envelope
            partials.forEach(({ratio, amp, decay}) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(fundamental * ratio, now);

                // Slight detuning for natural beating effect
                const detune = (Math.random() - 0.5) * 4;
                osc.detune.setValueAtTime(detune, now);

                osc.connect(gain);
                gain.connect(ctx.destination);

                // Bell envelope: quick attack, long exponential decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(amp, now + 0.003);
                gain.gain.exponentialRampToValueAtTime(0.001, now + decay);

                // Track node for cleanup
                this.#activeNodes.push(osc);
                osc.onended = () => {
                    const idx = this.#activeNodes.indexOf(osc);
                    if (idx > -1) this.#activeNodes.splice(idx, 1);
                };

                osc.start(now);
                osc.stop(now + decay + 0.1);
            });

            // Strike transient - short burst of filtered noise to simulate mallet impact
            const strikeLength = 0.08;
            const bufferSize = ctx.sampleRate * strikeLength;
            const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }

            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;

            const strikeFilter = ctx.createBiquadFilter();
            strikeFilter.type = 'bandpass';
            strikeFilter.frequency.value = fundamental * 2;
            strikeFilter.Q.value = 2;

            const strikeGain = ctx.createGain();
            strikeGain.gain.setValueAtTime(0.3, now);
            strikeGain.gain.exponentialRampToValueAtTime(0.001, now + strikeLength);

            noise.connect(strikeFilter);
            strikeFilter.connect(strikeGain);
            strikeGain.connect(ctx.destination);

            // Track noise node for cleanup
            this.#activeNodes.push(noise);
            noise.onended = () => {
                const idx = this.#activeNodes.indexOf(noise);
                if (idx > -1) this.#activeNodes.splice(idx, 1);
            };

            noise.start(now);
            noise.stop(now + strikeLength);
        }

        #stopAllBells() {
            // Stop all active audio nodes
            this.#activeNodes.forEach(node => {
                try {
                    node.stop();
                    node.disconnect();
                } catch (e) {
                    // Node may already be stopped
                }
            });
            this.#activeNodes = [];

            // Clear all scheduled bell timeouts
            this.#bellTimeouts.forEach(id => clearTimeout(id));
            this.#bellTimeouts = [];
        }

        // ==================== Wake Lock ====================

        // Prevents the screen from turning off during meditation
        async #requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    this.#wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock acquired');
                }
            } catch (err) {
                console.log('Wake Lock request failed:', err);
            }
        }

        async #releaseWakeLock() {
            if (this.#wakeLock !== null) {
                try {
                    await this.#wakeLock.release();
                    console.log('Wake Lock released');
                } catch (err) {
                    console.log('Wake Lock release failed:', err);
                }
                this.#wakeLock = null;
            }
        }

        // ==================== Media Session ====================

        // Configures the audio session type for proper background audio behavior
        // The 'playback' type signals to the OS that this is long-form audio content
        #setupAudioSession() {
            if ('audioSession' in navigator) {
                try {
                    navigator.audioSession.type = 'playback';
                } catch (err) {
                    console.log('Audio Session API setup failed:', err);
                }
            }
        }

        // Sets up lock screen / notification center controls
        #updateMediaSession() {
            if (!('mediaSession' in navigator)) return;

            navigator.mediaSession.metadata = new MediaMetadata({
                title: 'Meditation Timer',
                artist: 'Ripple',
                artwork: [{
                    src: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96"><circle cx="48" cy="48" r="45" fill="%23667eea"/></svg>',
                    sizes: '96x96',
                    type: 'image/svg+xml',
                }],
            });

            this.#setMediaSessionPlaying(true);
            navigator.mediaSession.setActionHandler('play', () => this.start());
            navigator.mediaSession.setActionHandler('pause', () => this.stop());
            navigator.mediaSession.setActionHandler('stop', () => this.stop());
            navigator.mediaSession.setActionHandler('seekto', (i) => console.log('seekto', i));
        }

        // Updates the progress bar shown in lock screen / notification center
        #updateMediaSessionPosition() {
            if (!('mediaSession' in navigator) || !navigator.mediaSession.setPositionState) return;

            const totalDuration = this.#selectedDuration +
                MeditationTimer.COUNTDOWN_DELAY +
                MeditationTimer.BELL_SEQUENCE_DURATION;

            let position;
            if (this.#delayStartTime !== null) {
                position = Math.round((Date.now() - this.#delayStartTime) / 1000);
            } else {
                position = MeditationTimer.COUNTDOWN_DELAY + (this.#selectedDuration - this.#timeRemaining);
            }

            try {
                navigator.mediaSession.setPositionState({
                    duration: totalDuration,
                    playbackRate: 1,
                    position: position,
                });
            } catch (err) {
                console.log('setPositionState not supported:', err);
            }
        }

        #setMediaSessionPlaying(playing) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = playing ? 'playing' : 'none';
            }
        }

        // ==================== UI State ====================

        #setButtonState(running) {
            this.#elements.startBtn.disabled = running;
            this.#elements.stopBtn.disabled = !running;
        }
    }

    new MeditationTimer();

    // Register service worker for PWA offline support
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js').catch(() => {});
    }
</script>
</body>
</html>
